package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{And => AmyAnd, Call => AmyCall, Div => AmyDiv, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm.{Instructions, _}
import Instructions._
import Utils._
import amyc.ast.NominalTreeModule.QualifiedName

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = expr match {
      case Variable(name) => GetLocal(locals(name))
      case IntLiteral(value) => Const(value)
      case BooleanLiteral(value) =>
        if (value) {
          Const(1)
        } else {
          Const(0)
        }
      case StringLiteral(value) => mkString(value)
      case UnitLiteral() => Const(0)
      case Plus(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs) <:> cgExpr(rhs) <:> Add
      case Minus(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
      case Times(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
      case AmyDiv(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs) <:> cgExpr(rhs) <:> Div
      case Mod(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
      case LessThan(lhs: Expr, rhs: Expr)  =>
        cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
      case LessEquals(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
      case AmyAnd(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs) <:> If_i32 <:>cgExpr(rhs) <:> Else <:> Const(0) <:> End
      case AmyOr(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs) <:> If_i32 <:> Const(1) <:> Else <:> cgExpr(rhs) <:> End
      case Equals(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
      case Concat(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs) <:> cgExpr(rhs) <:> Call(concatImpl.name)
      case Not(e) => cgExpr(e) <:> Eqz
      case Neg(e) => Const(0) <:> cgExpr(e) <:> Sub
      case AmyCall(qname, args: List[Expr]) =>
        //find out if it's a function or constructor call
        if (table.getFunction(qname).isDefined) {
          //function call
          val fun = table.getFunction(qname).get
          args.map(cgExpr) <:> Call(fullName(fun.owner, qname))
        } else {
          //constructor call
          val con = table.getConstructor(qname).get
          //save old memBound
          val oldBound = lh.getFreshLocal()
          val oldMemBound = GetGlobal(memoryBoundary) <:> SetLocal(oldBound)
          //increment old memBound by ADT size
          val incrBound = Const((args.size + 1) * 4) <:> GetGlobal(memoryBoundary) <:> Add <:> SetGlobal(memoryBoundary)
          //store constructor to predefined index
          val storeIndex = GetLocal(oldBound) <:> Const(con.index) <:> Store
          //store fields at right memory place
          val storeADT = args.zipWithIndex.map( {case (a, i) =>
            GetLocal(oldBound) <:> Const(4 * (i + 1)) <:> Add <:> cgExpr(a) <:> Store
          })
          //combine and push to stack at right address
          oldMemBound <:> incrBound <:> storeIndex <:> storeADT <:> GetLocal(oldBound)
        }
      case Sequence(e1: Expr, e2: Expr) =>
        cgExpr(e1) <:> Drop <:> cgExpr(e2)
      case Let(df, value: Expr, body: Expr) =>
        val localIndex = lh.getFreshLocal()
        cgExpr(value) <:> SetLocal(localIndex) <:> cgExpr(body)(locals + (df.name -> localIndex), lh)
      case Ite(cond: Expr, thenn: Expr, elze: Expr) =>
        cgExpr(cond) <:> If_i32 <:> cgExpr(thenn) <:> Else <:> cgExpr(elze) <:> End
      case Match(scrut: Expr, cases: List[MatchCase]) => {
        val scrutId = lh.getFreshLocal()

        def matchAndBind(p: Pattern): (Code, Map[Identifier, Int]) = p match {
          case WildcardPattern() => (Drop <:> Const(1), Map())
          case IdPattern(name) =>
            val newLoco = lh.getFreshLocal()
            (SetLocal(newLoco) <:> Const(1) ,Map(name -> newLoco))
          case LiteralPattern(lit) =>
            (cgExpr(lit) <:> Eq, Map())
          case CaseClassPattern(con, args) =>
            val constr = table.getConstructor(con).get
            val newLoco = lh.getFreshLocal()

            val compareConstrIndex = SetLocal(newLoco) <:> GetLocal(newLoco) <:> Load <:> Const(constr.index) <:> Eq

            if (args.size != 0) {
              val fieldsWithIndex = args.map(matchAndBind).zipWithIndex
              //
              val fieldsCode = fieldsWithIndex.map{case ((c, _), i) =>
                  GetLocal(newLoco) <:> adtField(i) <:> Load <:> c
              }
              //Map of all the locals
              val newLocos = fieldsWithIndex.flatMap{case ((_, locos), _) => locos}.toMap

              (compareConstrIndex <:>
                If_i32 <:>
                fieldsCode <:>
                args.map(_ => And).tail <:>
                Else <:>
                Const(0) <:>
                End, newLocos)

            } else {
              (compareConstrIndex, Map())
            }
        }

        val scrutCode = cgExpr(scrut) <:> SetLocal(scrutId)
        val matchCode = cases.map(c => {
          val (code, newLocos) = matchAndBind(c.pat)
          GetLocal(scrutId) <:> code <:> If_i32 <:> cgExpr(c.expr)(locals ++ newLocos, lh) <:> Else
        })

        scrutCode <:> matchCode <:> mkString("Match error!") <:> Call("Std_printString") <:> Unreachable <:> cases.map(_ => End)
      }
      case Error(msg: Expr) =>
        mkString("Error: ") <:> cgExpr(msg) <:> Call(concatImpl.name) <:> Call("Std_printString") <:> Unreachable
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}

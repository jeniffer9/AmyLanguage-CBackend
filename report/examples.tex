%Give code examples where your extension is useful, and describe how they work
%with it. Make sure you include examples where the most intricate features of
%your extension are used, so that we have an immediate understanding of what the
%challenges are.

It is a bit hard to give examples here because our project was not so much about improving a specific aspect of the Amy language but rather adding a new dimension to it. We produce human readable, well-known -- C code.

The C source files are simply generated by running the desired files similarly how we did it for WebAssembly. this time instead of /wasmout one receives a /cout folder with the translated source file inside. Some nice examples to try.

Perhaps my cool Fractional implementation in Amy which translates to cool C code. Who never wanted rational arithmetic in C?:

run library/Option.scala library/List.scala library/Std.scala examples/Fractional.scala

Generically one has following syntax for producing a C file called main.c with all the aforementioned modules included:
run \textless modules.scala* main.scala\textgreater\space

%You can pretty-print tool code like this:
%\begin{lstlisting}
%object {
%  def main() : Unit = { println(new A().foo(-41)); }
%}
%
%class A {
%  def foo(i : Int) : Int = {
%    var j : Int;
%    if(i < 0) { j = 0 - i; } else { j = i; }
%    return j + 1;
%  }
%}
%\end{lstlisting}

\begin{lstlisting}
Amy:
object Hello {
  Std.printString("Hello " ++ "world!")
}

becomes in C:
#include <stdio.h>
#include "std.h"

int Hello_main() {
  Std_printString(String_concat("Hello ", "world!"));
  return 0;
}
\end{lstlisting}

\begin{lstlisting}
One line of Amy code can generate a lot of C Code

case class Fractional(num: Int, denom: Int) extends Rational

becomes in C:
typedef struct Fractional {
  int param0; // numerator
  int param1; // denominator
} Fractional;

Rational Fractional_Constructor(int param0, int param1) 
{
  Fractional* fractional = malloc(sizeof(Fractional));
  fractional->param0 = param0;
  fractional->param1 = param1;

  Rational rational = malloc(sizeof(Abstract_Rational));
  rational->instance = fractional;
  rational->caseClass = 1;

  return rational;
}

#define instance_fractional(abstr_class)
	((Fractional*)abstr_class->instance)

\end{lstlisting}
This section should convince us that you understand how your extension can be
useful and that you thought about the corner cases.

This is a very important section, you explain to us how you made it work.

\subsection{Theoretical Background}
If you are using theoretical concepts, explain them first in this subsection.
Even if they come from the course (eg. lattices), try to explain the essential
points \emph{in your own words}. Cite any reference work you used like this
\cite{TigerBook}. This should convince us that you know the theory behind what
you coded.

For the pattern matching we went on with the matchAndBinding function approach which returns a boolean and the new defined locals for and individual case, as we have seen in the course.
With the boolean we evaluate, if the specific case is the one we should truly be matching on.
The condition also includes the parameters. So basically for a wildcard and an id pattern it is always true.
For the id pattern, the id is then additionally added to the list of locals, associating the expression that is being matched on with the this newly defined id.
For the Case Classes we check that it's the same Class for the given type and the the literals we match directly on the matching expression.

\subsection{Implementation Details}
%Describe all non-obvious tricks you used. Tell us what you thought was hard and
%why. If it took you time to figure out the solution to a problem, it probably
%means it wasn't easy and you should definitely describe the solution in details
%here. If you used what you think is a cool algorithm for some problem, tell us.
%Do not however spend time describing trivial things (we what a tree traversal
%is, for instance). 
%
%After reading this section, we should be convinced that you knew what you were
%doing when you wrote your extension, and that you put some extra consideration
%for the harder parts.
In a separate package called "c" we basically define all the elements that were also defined in the webAssembly code generation; Function, Instructions, Module and ModulePrinter.
Additionally we added an AbstractClass and a CaseClass, inspired from the Function file and that are used to correctly implement an alternative to types and classes in C.

AbstractClass: (takes the typeName as parameter)
The abstract class implements the equivalent to a type by creating a struct with the defined type name, typedefing it to
it's "abstract name" - which consists simply by adding "Abstract_" in front of it - and then simutaneously creating a pointer
which is being used whenever make use of the type.

CaseClass: (takes: name, list of it's fields, case index, type)
We are here making use of the individual index assigned to each constructor for each type
Basicaly, every time we call a constructor, the C code calls the associated constructor which does all the work for us and
just returns the right type struct containing a pointer to aninstance of the actual CaseClass and a caseClass field containing
the index which will be very useful when implementing the pattern matching.

The hardest part was finding a working and readable substitution for Amy's abstract and case class (which extend the abstract class) functionality.
How can we have "generics" and "inheritance" in C: that seemed like an impossible challenge.
So we contemplated on how to achieve this and sat down and tried to come up with ways

In the Utils file we created a trait "CType" and an implicit def which converty types from the TreeModule to CTypes.
This is needed because for C every variable declaration, every function parameter and every Function has a type or return type.

We made sure that in the beginning of the module printer all the function declarations are printed, such that we can call on functions before we implement them.
The stdio, stdlib, string and stdbool header files are also included in every module such that builtin functions like scanf and printf and also the bool types can be easily used in the code generation.
